{
  "id": "msg-1757186955-fDSERmUKVxZQai4SQ2pX",
  "type": "assistant",
  "parentMessageId": "msg-1757186955-PMAVWz5g5hxhpBjlD2bK",
  "context": "main-chat",
  "contentType": "text",
  "characterId": "char-1757186036-zJwht4eAyb6weGk1h76I",
  "citations": [],
  "images": [],
  "files": [],
  "createdAt": "2025-09-06T19:29:15.586Z",
  "updatedAt": "2025-09-06T19:35:33.391Z",
  "isGenerating": false,
  "isRetrying": false,
  "isEdited": false,
  "isCollapsed": true,
  "metadata": {
    "plugins": [],
    "generateDuration": 20477,
    "latencyDuration": 1068,
    "reasoningDuration": 954,
    "tokensCount": 2366,
    "tokensPerSecond": 115.54426918005566,
    "variantSlug": "deepseek/deepseek-chat-v3.1",
    "provider": "Fireworks",
    "cost": "0.00414848"
  },
  "reasoning": "We are going to create two main parts:\n 1. The backend part: a function `AppError` that returns a class (the error class) with a static property `code` and an instance that has a `code` property.\n 2. The frontend part: a function `matchErrorClass` that checks if an error object has a `code` property that matches the static `code` of the given error class.\n\n Let's break down the types and the implementation.\n\n For the backend:\n   - We want `AppError` to take a string `code` and return a class that has:\n        - A static property `code` set to the provided string.\n        - Instances of the class should have a `code` property (the same string) and also be an instance of Error (or at least have a message, but the requirement doesn't specify, so we'll make them Error objects).\n\n   However, note the example: `class AuthTokenError extends AppError(\"AUTH_TOKEN\") {}`\n   This means `AppError` returns a class that we can extend.\n\n   We'll define the type for the error class instance and the class constructor.\n\n   Let's define:\n        type AppErrorType = {\n            code: string;\n            message: string;\n            // We may want to have other Error properties, but the requirement only specifies code.\n            // Since we are extending Error, we get stack, name, etc.\n        };\n\n   But note: the example extends the class returned by `AppError`, so we want that class to be an Error subclass.\n\n   So we'll have:\n        function AppError(code: string): { new (message?: string): AppErrorType } & { code: string }\n\n   However, the example usage extends it, so we must return a class that is constructible and has the static `code`.\n\n   Alternatively, we can return a class that extends Error and has the static `code` and also the instance `code` set.\n\n   We can do:\n\n        const AppError = (code: string) => {\n            return class AppErrorClass extends Error {\n                static code = code;\n                public code: string = code;\n\n                constructor(message?: string) {\n                    super(message);\n                    this.name = this.constructor.name;\n                }\n            };\n        };\n\n   But wait, the requirement says the function is called `AppError` and returns a class of `AppErrorType`. We need to type it appropriately.\n\n   However, note the frontend function `matchErrorClass` expects the class to have a static `code` and the instance to have a `code` of the same type.\n\n   Also, the frontend function uses `E[\"code\"]` which is the type of the static `code` property.\n\n   Let's define the type for the error class:\n\n        type AppErrorClass = {\n            new (message?: string): { code: string };\n            code: string;\n        };\n\n   But note: the error instance might have more properties (like message, stack, etc.), but we only care about `code` for matching.\n\n   Now, for the frontend function:\n\n        function matchErrorClass<E extends AppErrorClass>(error: object, ErrorClass: E): error is { code: E[\"code\"] } {\n            return (error as any).code === ErrorClass.code;\n        }\n\n   However, the rule says no `as any`. We can do:\n\n        function matchErrorClass<E extends AppErrorClass>(error: object, ErrorClass: E): error is { code: E[\"code\"] } {\n            return 'code' in error && (error as { code: unknown }).code === ErrorClass.code;\n        }\n\n   But note: the error object might not have a code, so we check for existence. However, we are casting to `{ code: unknown }` to avoid any, but then we compare.\n\n   Alternatively, we can write:\n\n        function matchErrorClass<E extends AppErrorClass>(error: object, ErrorClass: E): error is { code: E[\"code\"] } {\n            if (typeof error === 'object' && error !== null && 'code' in error) {\n                return (error as { code: unknown }).code === ErrorClass.code;\n            }\n            return false;\n        }\n\n   But note: the requirement says the error body is an object. We assume it might be any object.\n\n   However, we are only checking for the code. We want the type guard to narrow the type to `{ code: E[\"code\"] }`. But note, the error might have more properties, so we are only checking the code.\n\n   Let's adjust the type of the error in the type guard: we are returning that the error is of type `{ code: E[\"code\"] }`. This is correct because we are only checking the code and we don't care about other properties.\n\n   But wait, the error might be an object with a `code` property that is a string, but we are comparing it to `ErrorClass.code` which is of type `E[\"code\"]` (which is string in this case, but could be a string literal if we use const string in the backend). However, the function `AppError` takes a string, so the static code is a string. But when we extend, we might have a string literal type if we use `as const` or if the string is a literal. But the example uses a string literal. We want to preserve the literal type in the class.\n\n   How can we make the static `code` a string literal type? We can use a generic in the `AppError` function to capture the literal type of the code.\n\n   Let's change the `AppError` function to be generic:\n\n        function AppError<Code extends string>(code: Code) {\n            return class AppErrorClass extends Error {\n                static code: Code = code;\n                public code: Code;\n\n                constructor(message?: string) {\n                    super(message);\n                    this.code = code;\n                    this.name = this.constructor.name;\n                }\n            };\n        }\n\n   Now, when we do `AppError(\"AUTH_TOKEN\")`, the returned class has static `code` of type \"AUTH_TOKEN\", and instances have `code` of type \"AUTH_TOKEN\".\n\n   Then, the frontend function `matchErrorClass` will work with these literal types.\n\n   Now, what is the type of the class returned by `AppError`? It is:\n\n        typeof AppErrorClass (which has static code: Code) and constructs instances with code: Code.\n\n   So we can define:\n\n        type AppErrorClass<Code extends string> = {\n            new (message?: string): { code: Code };\n            code: Code;\n        };\n\n   And then the frontend function becomes:\n\n        function matchErrorClass<Code extends string>(error: object, ErrorClass: AppErrorClass<Code>): error is { code: Code } {\n            return typeof error === 'object' && error !== null && 'code' in error && (error as { code: unknown }).code === ErrorClass.code;\n        }\n\n   But note: the requirement for `matchErrorClass` is:\n\n        <E extends Class<AppErrorType>>(error: object, ErrorClass: E): error is { code: E[\"code\"] }\n\n   We are changing it to use a generic `Code` instead of `E` (the class type). Alternatively, we can keep the class type and use `E` extends `AppErrorClass<Code>` for some `Code`, but TypeScript doesn't allow that directly.\n\n   Alternatively, we can define:\n\n        type AppErrorType<Code extends string> = { code: Code };\n\n        type AppErrorClass<Code extends string> = {\n            new (message?: string): AppErrorType<Code>;\n            code: Code;\n        };\n\n   And then the function:\n\n        function matchErrorClass<Code extends string>(error: object, ErrorClass: AppErrorClass<Code>): error is AppErrorType<Code> {\n            // ... same implementation\n        }\n\n   But the requirement says the function should take `E extends Class<AppErrorType>`. We don't have a non-parameterized `AppErrorType` in the original, so we are modifying as per the rules.\n\n   However, note the original requirement for `matchErrorClass`:\n\n        matchErrorClass: <E extends Class<AppErrorType>>(error: object, ErrorClass: E): error is { code: E[\"code\"] }\n\n   We are going to change the types to be more specific and safe.\n\n   Let's stick with the generic Code version, because it allows literal types and is more straightforward.\n\n   But wait, the requirement says the error class is `Class<AppErrorType>`, which we can interpret as a class that has a static `code` and instances with a `code` of the same type. We are defining `AppErrorClass<Code>`.\n\n   So we'll implement:\n\n        // Backend\n        function AppError<Code extends string>(code: Code): AppErrorClass<Code> {\n            return class AppErrorClass extends Error {\n                static code: Code = code;\n                public code: Code;\n\n                constructor(message?: string) {\n                    super(message);\n                    this.code = code;\n                    this.name = this.constructor.name;\n                }\n            };\n        }\n\n        // Frontend\n        function matchErrorClass<Code extends string>(error: object, ErrorClass: AppErrorClass<Code>): error is AppErrorType<Code> {\n            return (typeof error === 'object' && error !== null && 'code' in error && (error as { code: unknown }).code === ErrorClass.code);\n        }\n\n   We need to define the types `AppErrorType<Code>` and `AppErrorClass<Code>`.\n\n   Alternatively, we can inline them, but for clarity we'll define them.\n\n   However, the rule says to only add brief JSDoc comments and keep it simple.\n\n   Let's write the code accordingly.\n\n   Note: The example error class `AuthTokenError` extends `AppError(\"AUTH_TOKEN\")` so we must export `AppError` and the types if needed.\n\n   We are only writing the code, so we'll assume everything is in one module.\n\n   Let's code accordingly.",
  "content": "```typescript\ntype AppErrorType<Code extends string> = {\n  code: Code;\n  message: string;\n};\n\ntype AppErrorClass<Code extends string> = {\n  new (message?: string): AppErrorType<Code>;\n  code: Code;\n};\n\n/**\n * Creates an error class with a specific error code\n */\nfunction AppError<Code extends string>(code: Code): AppErrorClass<Code> {\n  return class AppErrorClass extends Error {\n    static code = code;\n    public code: Code;\n\n    constructor(message: string = '') {\n      super(message);\n      this.code = code;\n      this.name = this.constructor.name;\n    }\n  };\n}\n\n/**\n * Checks if an error object matches a specific error class\n */\nfunction matchErrorClass<Code extends string>(\n  error: object,\n  ErrorClass: AppErrorClass<Code>\n): error is AppErrorType<Code> {\n  return 'code' in error && (error as { code: string }).code === ErrorClass.code;\n}\n```"
}
