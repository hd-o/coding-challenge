{
  "id": "msg-1757186955-Mt01bSBqWYdebB9oZFaH",
  "type": "assistant",
  "parentMessageId": "msg-1757186955-PMAVWz5g5hxhpBjlD2bK",
  "context": "main-chat",
  "contentType": "text",
  "characterId": "char-1757186146-XYroBuA3epzNKclLYlT4",
  "citations": [],
  "images": [],
  "files": [],
  "createdAt": "2025-09-06T19:29:15.591Z",
  "updatedAt": "2025-09-06T19:40:36.434Z",
  "isGenerating": false,
  "isRetrying": false,
  "isEdited": false,
  "isCollapsed": true,
  "metadata": {
    "plugins": [],
    "variantSlug": "z-ai/glm-4.5",
    "latencyDuration": 4804,
    "generateDuration": 148044,
    "tokensCount": 6994,
    "tokensPerSecond": 47.24271162627327,
    "provider": "AtlasCloud",
    "cost": "0.0155698",
    "reasoningDuration": 134176
  },
  "reasoning": "Let me implement the requested feature in TypeScript. I'll analyze what's needed:\n\n1. A function `AppError` that takes a code string and returns a class that extends `AppErrorType`.\n2. An example error class `AuthTokenError` that uses this function.\n3. A function `matchErrorClass` for the frontend that checks if a network error response matches a particular error class.\n\nLet's start by defining the core types and functions:\n\nFirst, I need to define what `AppErrorType` should be. It should be a base class or interface that has at least a `code` property.\n\nThen, I need to create the `AppError` function that returns a class with the given code.\n\nFinally, I need to implement the `matchErrorClass` function that does type narrowing to check if an error object matches a specific error class.\n\nHere's the implementation:\n\n```typescript\ntype AppErrorType = {\n  code: string;\n  message?: string;\n};\n\nfunction AppError(code: string): Class<AppErrorType> {\n  return class implements AppErrorType {\n    code = code;\n    message?: string;\n\n    constructor(message?: string) {\n      this.message = message;\n    }\n  };\n}\n\nclass AuthTokenError extends AppError(\"AUTH_TOKEN\") {}\n\nfunction matchErrorClass<E extends Class<AppErrorType>>(error: object, ErrorClass: E): error is { code: E[\"code\"] } {\n  return error.hasOwnProperty('code') && (error as { code: string }).code === ErrorClass.prototype.code;\n}\n```\n\nBut wait, I need to define what `Class<T>` is. It's a common pattern to define a class constructor type:\n\n```typescript\ntype Class<T> = new (...args: any[]) => T;\n```\n\nLet me refine the implementation further. The `matchErrorClass` function needs to check if the error object has a `code` property that matches the `code` property of the error class. However, TypeScript might have issues with accessing static properties vs instance properties.\n\nLet me adjust the approach:\n\n```typescript\ntype AppErrorType = {\n  code: string;\n  message?: string;\n};\n\ntype Class<T> = new (...args: any[]) => T;\n\nfunction AppError(code: string): Class<AppErrorType> {\n  return class implements AppErrorType {\n    code = code;\n    message?: string;\n\n    constructor(message?: string) {\n      this.message = message;\n    }\n  };\n}\n\nclass AuthTokenError extends AppError(\"AUTH_TOKEN\") {}\n\nfunction matchErrorClass<E extends Class<AppErrorType>>(error: object, ErrorClass: E): error is { code: E[\"prototype\"][\"code\"] } {\n  const errorInstance = new ErrorClass();\n  return error.hasOwnProperty('code') && (error as { code: string }).code === errorInstance.code;\n}\n```\n\nBut there's still an issue with the return type of `matchErrorClass`. It should be a type predicate that narrows down the error object to have the specific code of the error class. Let me refine it further:\n\n```typescript\ntype AppErrorType = {\n  code: string;\n  message?: string;\n};\n\ntype Class<T> = new (...args: any[]) => T;\n\nfunction AppError(code: string): Class<AppErrorType> {\n  return class implements AppErrorType {\n    static readonly code = code;\n    code = code;\n    message?: string;\n\n    constructor(message?: string) {\n      this.message = message;\n    }\n  };\n}\n\nclass AuthTokenError extends AppError(\"AUTH_TOKEN\") {}\n\nfunction matchErrorClass<E extends Class<AppErrorType>>(error: object, ErrorClass: E): error is { code: E[\"code\"] } {\n  return error.hasOwnProperty('code') && (error as { code: string }).code === (ErrorClass as any).code;\n}\n```\n\nIn this version, I added a static `code` property to the error class returned by `AppError`, so we can access it directly from the class in `matchErrorClass`. But I'm using `(ErrorClass as any).code` which violates the rule of not using `as any`. Let's fix that:\n\n```typescript\ntype AppErrorType = {\n  code: string;\n  message?: string;\n};\n\ntype Class<T> = new (...args: any[]) => T;\n\ninterface AppErrorConstructor<T extends AppErrorType> extends Class<T> {\n  code: string;\n}\n\nfunction AppError(code: string): AppErrorConstructor<AppErrorType> {\n  return class implements AppErrorType {\n    static readonly code = code;\n    code = code;\n    message?: string;\n\n    constructor(message?: string) {\n      this.message = message;\n    }\n  };\n}\n\nclass AuthTokenError extends AppError(\"AUTH_TOKEN\") {}\n\nfunction matchErrorClass<E extends AppErrorConstructor<AppErrorType>>(\n  error: object, \n  ErrorClass: E\n): error is { code: E[\"code\"] } {\n  return error.hasOwnProperty('code') && (error as { code: string }).code === ErrorClass.code;\n}\n```\n\nThis looks better. I've defined an `AppErrorConstructor` interface that extends the `Class` type and adds a `code` property. Now I can access `ErrorClass.code` without type casting.\n\nBut I'm not sure if this is exactly what was requested. The original request was for `matchErrorClass` to return a type predicate `error is { code: E[\"code\"] }`. Let me make sure this aligns with the specification:\n\n```typescript\ntype AppErrorType = {\n  code: string;\n  message?: string;\n};\n\ntype Class<T> = new (...args: any[]) => T;\n\ninterface AppErrorConstructor<T extends AppErrorType> extends Class<T> {\n  code: string;\n}\n\nfunction AppError(code: string): AppErrorConstructor<AppErrorType> {\n  return class implements AppErrorType {\n    static readonly code = code;\n    code = code;\n    message?: string;\n\n    constructor(message?: string) {\n      this.message = message;\n    }\n  };\n}\n\nclass AuthTokenError extends AppError(\"AUTH_TOKEN\") {}\n\nfunction matchErrorClass<E extends AppErrorConstructor<AppErrorType>>(\n  error: object, \n  ErrorClass: E\n): error is { code: E[\"code\"] } {\n  return error.hasOwnProperty('code') && (error as { code: string }).code === ErrorClass.code;\n}\n```\n\nI think this implementation satisfies all the requirements. Let me review it against the rules:\n\n1. I've implemented the `AppError` function that takes a code string and returns a class.\n2. I've provided the example `AuthTokenError` class.\n3. I've implemented the `matchErrorClass` function for frontend matching.\n4. I'm not using `as any` type casting.\n5. All functions have return types.\n6. The implementation is simple and focuses on strong typing.\n\nThe only potential issue is that the type of `error` in `matchErrorClass` is `object`, which might be too broad. But I think it's acceptable since we're checking if the error object has a `code` property.\n\nOK, now I'm ready to provide the final implementation:\n\n```typescript\ntype AppErrorType = {\n  code: string;\n  message?: string;\n};\n\ntype Class<T> = new (...args: any[]) => T;\n\ninterface AppErrorConstructor<T extends AppErrorType> extends Class<T> {\n  code: string;\n}\n\nfunction AppError(code: string): AppErrorConstructor<AppErrorType> {\n  return class implements AppErrorType {\n    static readonly code = code;\n    code = code;\n    message?: string;\n\n    constructor(message?: string) {\n      this.message = message;\n    }\n  };\n}\n\nclass AuthTokenError extends AppError(\"AUTH_TOKEN\") {}\n\nfunction matchErrorClass<E extends AppErrorConstructor<AppErrorType>>(\n  error: object, \n  ErrorClass: E\n): error is { code: E[\"code\"] } {\n  return error.hasOwnProperty('code') && (error as { code: string }).code === ErrorClass.code;\n}\n```\n\nActually, I just realized I'm using `(error as { code: string }).code`, which is a form of type casting. Let me fix that:\n\n```typescript\ntype AppErrorType = {\n  code: string;\n  message?: string;\n};\n\ntype Class<T> = new (...args: any[]) => T;\n\ninterface AppErrorConstructor<T extends AppErrorType> extends Class<T> {\n  code: string;\n}\n\nfunction AppError(code: string): AppErrorConstructor<AppErrorType> {\n  return class implements AppErrorType {\n    static readonly code = code;\n    code = code;\n    message?: string;\n\n    constructor(message?: string) {\n      this.message = message;\n    }\n  };\n}\n\nclass AuthTokenError extends AppError(\"AUTH_TOKEN\") {}\n\nfunction matchErrorClass<E extends AppErrorConstructor<AppErrorType>>(\n  error: object, \n  ErrorClass: E\n): error is { code: E[\"code\"] } {\n  return 'code' in error && (error as { code: unknown }).code === ErrorClass.code;\n}\n```\n\nBut that's still a type cast. Let me think of a better way:\n\n```typescript\ntype AppErrorType = {\n  code: string;\n  message?: string;\n};\n\ntype Class<T> = new (...args: any[]) => T;\n\ninterface AppErrorConstructor<T extends AppErrorType> extends Class<T> {\n  code: string;\n}\n\nfunction AppError(code: string): AppErrorConstructor<AppErrorType> {\n  return class implements AppErrorType {\n    static readonly code = code;\n    code = code;\n    message?: string;\n\n    constructor(message?: string) {\n      this.message = message;\n    }\n  };\n}\n\nclass AuthTokenError extends AppError(\"AUTH_TOKEN\") {}\n\nfunction matchErrorClass<E extends AppErrorConstructor<AppErrorType>>(\n  error: object, \n  ErrorClass: E\n): error is { code: E[\"code\"] } {\n  const errorWithCode = error as Partial<{ code: string }>;\n  return typeof errorWithCode.code === 'string' && errorWithCode.code === ErrorClass.code;\n}\n```\n\nThat's better, but I'm still using a type cast. Let me try a different approach:\n\n```typescript\ntype AppErrorType = {\n  code: string;\n  message?: string;\n};\n\ntype Class<T> = new (...args: any[]) => T;\n\ninterface AppErrorConstructor<T extends AppErrorType> extends Class<T> {\n  code: string;\n}\n\nfunction AppError(code: string): AppErrorConstructor<AppErrorType> {\n  return class implements AppErrorType {\n    static readonly code = code;\n    code = code;\n    message?: string;\n\n    constructor(message?: string) {\n      this.message = message;\n    }\n  };\n}\n\nclass AuthTokenError extends AppError(\"AUTH_TOKEN\") {}\n\nfunction matchErrorClass<E extends AppErrorConstructor<AppErrorType>>(\n  error: unknown, \n  ErrorClass: E\n): error is { code: E[\"code\"] } {\n  return !!(error && typeof error === 'object' && 'code' in error && (error as { code: string }).code === ErrorClass.code);\n}\n```\n\nBut again, I'm using a type cast. Let me revisit the approach. Maybe I can use a type guard function to check if the error has a code property:\n\n```typescript\nfunction hasCodeProperty(error: unknown): error is { code: unknown } {\n  return !!(error && typeof error === 'object' && 'code' in error);\n}\n\nfunction matchErrorClass<E extends AppErrorConstructor<AppErrorType>>(\n  error: unknown, \n  ErrorClass: E\n): error is { code: E[\"code\"] } {\n  return hasCodeProperty(error) && error.code === ErrorClass.code;\n}\n```\n\nThis is better, but TypeScript might not be able to infer that `error.code` is a string. Let me refine it:\n\n```typescript\nfunction hasStringCodeProperty(error: unknown): error is { code: string } {\n  return !!(error && typeof error === 'object' && 'code' in error && typeof (error as { code: unknown }).code === 'string');\n}\n\nfunction matchErrorClass<E extends AppErrorConstructor<AppErrorType>>(\n  error: unknown, \n  ErrorClass: E\n): error is { code: E[\"code\"] } {\n  return hasStringCodeProperty(error) && error.code === ErrorClass.code;\n}\n```\n\nBut I'm still using a type cast in `hasStringCodeProperty`. Let me try a different approach:\n\n```typescript\nfunction hasStringCodeProperty(error: unknown): error is { code: string } {\n  if (!error || typeof error !== 'object') return false;\n  const errorObj = error as Record<string, unknown>;\n  return 'code' in errorObj && typeof errorObj.code === 'string';\n}\n\nfunction matchErrorClass<E extends AppErrorConstructor<AppErrorType>>(\n  error: unknown, \n  ErrorClass: E\n): error is { code: E[\"code\"] } {\n  return hasStringCodeProperty(error) && error.code === ErrorClass.code;\n}\n```\n\nThis is better. Now I'm using `Record<string, unknown>` which is a more appropriate type cast in this context. Let me put it all together:\n\n```typescript\ntype AppErrorType = {\n  code: string;\n  message?: string;\n};\n\ntype Class<T> = new (...args: any[]) => T;\n\ninterface AppErrorConstructor<T extends AppErrorType> extends Class<T> {\n  code: string;\n}\n\nfunction AppError(code: string): AppErrorConstructor<AppErrorType> {\n  return class implements AppErrorType {\n    static readonly code = code;\n    code = code;\n    message?: string;\n\n    constructor(message?: string) {\n      this.message = message;\n    }\n  };\n}\n\nclass AuthTokenError extends AppError(\"AUTH_TOKEN\") {}\n\nfunction hasStringCodeProperty(error: unknown): error is { code: string } {\n  if (!error || typeof error !== 'object') return false;\n  const errorObj = error as Record<string, unknown>;\n  return 'code' in errorObj && typeof errorObj.code === 'string';\n}\n\nfunction matchErrorClass<E extends AppErrorConstructor<AppErrorType>>(\n  error: unknown, \n  ErrorClass: E\n): error is { code: E[\"code\"] } {\n  return hasStringCodeProperty(error) && error.code === ErrorClass.code;\n}\n```\n\nI think this implementation satisfies all the requirements without using any explicit `as any` type casts. Now, let me add some brief jsdoc comments as requested:\n\n```typescript\ntype AppErrorType = {\n  code: string;\n  message?: string;\n};\n\ntype Class<T> = new (...args: any[]) => T;\n\ninterface AppErrorConstructor<T extends AppErrorType> extends Class<T> {\n  code: string;\n}\n\n/** Creates an error class with the given code. */\nfunction AppError(code: string): AppErrorConstructor<AppErrorType> {\n  return class implements AppErrorType {\n    static readonly code = code;\n    code = code;\n    message?: string;\n\n    constructor(message?: string) {\n      this.message = message;\n    }\n  };\n}\n\nclass AuthTokenError extends AppError(\"AUTH_TOKEN\") {}\n\n/** Type guard to check if an error has a string code property. */\nfunction hasStringCodeProperty(error: unknown): error is { code: string } {\n  if (!error || typeof error !== 'object') return false;\n  const errorObj = error as Record<string, unknown>;\n  return 'code' in errorObj && typeof errorObj.code === 'string';\n}\n\n/** Matches an error to an error class, returning a type predicate. */\nfunction matchErrorClass<E extends AppErrorConstructor<AppErrorType>>(\n  error: unknown, \n  ErrorClass: E\n): error is { code: E[\"code\"] } {\n  return hasStringCodeProperty(error) && error.code === ErrorClass.code;\n}\n```\n\nI think this is the final implementation that meets all the requirements. Let me review it one more time:\n\n1. I've implemented the `AppError` function that takes a code string and returns a class.\n2. I've provided the example `AuthTokenError` class.\n3. I've implemented the `matchErrorClass` function for frontend matching.\n4. I'm not using `as any` type casting.\n5. All functions have return types.\n6. The implementation is simple and focuses on strong typing.\n7. I've added brief jsdoc comments.\n\nI'm happy with this implementation. Now, let's format it for the final answer:\n\n```typescript\ntype AppErrorType = {\n  code: string;\n  message?: string;\n};\n\ntype Class<T> = new (...args: any[]) => T;\n\ninterface AppErrorConstructor<T extends AppErrorType> extends Class<T> {\n  code: string;\n}\n\n/** Creates an error class with the given code. */\nfunction AppError(code: string): AppErrorConstructor<AppErrorType> {\n  return class implements AppErrorType {\n    static readonly code = code;\n    code = code;\n    message?: string;\n\n    constructor(message?: string) {\n      this.message = message;\n    }\n  };\n}\n\nclass AuthTokenError extends AppError(\"AUTH_TOKEN\") {}\n\n/** Type guard to check if an error has a string code property. */\nfunction hasStringCodeProperty(error: unknown): error is { code: string } {\n  if (!error || typeof error !== 'object') return false;\n  const errorObj = error as Record<string, unknown>;\n  return 'code' in errorObj && typeof errorObj.code === 'string';\n}\n\n/** Matches an error to an error class, returning a type predicate. */\nfunction matchErrorClass<E extends AppErrorConstructor<AppErrorType>>(error: unknown, ErrorClass: E): error is { code: E[\"code\"] } {\n  return hasStringCodeProperty(error) && error.code === ErrorClass.code;\n}\n```\n\nOne more thing. Looking back at the original request, the type of `matchErrorClass` should take `error: object`, not `error: unknown`. Let me adjust that:\n\n```typescript\ntype AppErrorType = {\n  code: string;\n  message?: string;\n};\n\ntype Class<T> = new (...args: any[]) => T;\n\ninterface AppErrorConstructor<T extends AppErrorType> extends Class<T> {\n  code: string;\n}\n\n/** Creates an error class with the given code. */\nfunction AppError(code: string): AppErrorConstructor<AppErrorType> {\n  return class implements AppErrorType {\n    static readonly code = code;\n    code = code;\n    message?: string;\n\n    constructor(message?: string) {\n      this.message = message;\n    }\n  };\n}\n\nclass AuthTokenError extends AppError(\"AUTH_TOKEN\") {}\n\n/** Type guard to check if an error has a string code property. */\nfunction hasStringCodeProperty(error: object): error is { code: string } {\n  const errorObj = error as Record<string, unknown>;\n  return 'code' in errorObj && typeof errorObj.code === 'string';\n}\n\n/** Matches an error to an error class, returning a type predicate. */\nfunction matchErrorClass<E extends AppErrorConstructor<AppErrorType>>(error: object, ErrorClass: E): error is { code: E[\"code\"] } {\n  return hasStringCodeProperty(error) && (error as { code: string }).code === ErrorClass.code;\n}\n```\n\nBut now I'm back to using a type cast in `matchErrorClass`. Let me fix that:\n\n```typescript\ntype AppErrorType = {\n  code: string;\n  message?: string;\n};\n\ntype Class<T> = new (...args: any[]) => T;\n\ninterface AppErrorConstructor<T extends AppErrorType> extends Class<T> {\n  code: string;\n}\n\n/** Creates an error class with the given code. */\nfunction AppError(code: string): AppErrorConstructor<AppErrorType> {\n  return class implements AppErrorType {\n    static readonly code = code;\n    code = code;\n    message?: string;\n\n    constructor(message?: string) {\n      this.message = message;\n    }\n  };\n}\n\nclass AuthTokenError extends AppError(\"AUTH_TOKEN\") {}\n\n/** Type guard to check if an error has a string code property. */\nfunction hasStringCodeProperty(error: object): error is { code: string } {\n  const errorObj = error as Record<string, unknown>;\n  return 'code' in errorObj && typeof errorObj.code === 'string';\n}\n\n/** Matches an error to an error class, returning a type predicate. */\nfunction matchErrorClass<E extends AppErrorConstructor<AppErrorType>>(error: object, ErrorClass: E): error is { code: E[\"code\"] } {\n  if (!hasStringCodeProperty(error)) return false;\n  return error.code === ErrorClass.code;\n}\n```\n\nThat's better. Now I'm not using any type casts in `matchErrorClass`. This is the final implementation.\n\nActually, I can simplify this even further by removing the `hasStringCodeProperty` function and doing the check directly in `matchErrorClass`:\n\n```typescript\ntype AppErrorType = {\n  code: string;\n  message?: string;\n};\n\ntype Class<T> = new (...args: any[]) => T;\n\ninterface AppErrorConstructor<T extends AppErrorType> extends Class<T> {\n  code: string;\n}\n\n/** Creates an error class with the given code. */\nfunction AppError(code: string): AppErrorConstructor<AppErrorType> {\n  return class implements AppErrorType {\n    static readonly code = code;\n    code = code;\n    message?: string;\n\n    constructor(message?: string) {\n      this.message = message;\n    }\n  };\n}\n\nclass AuthTokenError extends AppError(\"AUTH_TOKEN\") {}\n\n/** Matches an error to an error class, returning a type predicate. */\nfunction matchErrorClass<E extends AppErrorConstructor<AppErrorType>>(error: object, ErrorClass: E): error is { code: E[\"code\"] } {\n  const errorObj = error as Record<string, unknown>;\n  return 'code' in errorObj && typeof errorObj.code === 'string' && errorObj.code === ErrorClass.code;\n}\n```\n\nI think this is the simplest and most straightforward implementation that meets all the requirements. Let's finalize this:\n\n```typescript\ntype AppErrorType = {\n  code: string;\n  message?: string;\n};\n\ntype Class<T> = new (...args: any[]) => T;\n\ninterface AppErrorConstructor<T extends AppErrorType> extends Class<T> {\n  code: string;\n}\n\n/** Creates an error class with the given code. */\nfunction AppError(code: string): AppErrorConstructor<AppErrorType> {\n  return class implements AppErrorType {\n    static readonly code = code;\n    code = code;\n    message?: string;\n\n    constructor(message?: string) {\n      this.message = message;\n    }\n  };\n}\n\nclass AuthTokenError extends AppError(\"AUTH_TOKEN\") {}\n\n/** Matches an error to an error class, returning a type predicate. */\nfunction matchErrorClass<E extends AppErrorConstructor<AppErrorType>>(error: object, ErrorClass: E): error is { code: E[\"code\"] } {\n  const errorObj = error as Record<string, unknown>;\n  return 'code' in errorObj && typeof errorObj.code === 'string' && errorObj.code === ErrorClass.code;\n}\n```\n\nActually, wait. I'm still using a type cast with `as Record<string, unknown>`. Let me see if I can avoid that:\n\n```typescript\ntype AppErrorType = {\n  code: string;\n  message?: string;\n};\n\ntype Class<T> = new (...args: any[]) => T;\n\ninterface AppErrorConstructor<T extends AppErrorType> extends Class<T> {\n  code: string;\n}\n\n/** Creates an error class with the given code. */\nfunction AppError(code: string): AppErrorConstructor<AppErrorType> {\n  return class implements AppErrorType {\n    static readonly code = code;\n    code = code;\n    message?: string;\n\n    constructor(message?: string) {\n      this.message = message;\n    }\n  };\n}\n\nclass AuthTokenError extends AppError(\"AUTH_TOKEN\") {}\n\n/** Matches an error to an error class, returning a type predicate. */\nfunction matchErrorClass<E extends AppErrorConstructor<AppErrorType>>(error: object, ErrorClass: E): error is { code: E[\"code\"] } {\n  if (!('code' in error)) return false;\n  const errorCode = (error as { code: unknown }).code;\n  return typeof errorCode === 'string' && errorCode === ErrorClass.code;\n}\n```\n\nBut I'm still using a type cast here. Let me try a different approach:\n\n```typescript\ntype AppErrorType = {\n  code: string;\n  message?: string;\n};\n\ntype Class<T> = new (...args: any[]) => T;\n\ninterface AppErrorConstructor<T extends AppErrorType> extends Class<T> {\n  code: string;\n}\n\n/** Creates an error class with the given code. */\nfunction AppError(code: string): AppErrorConstructor<AppErrorType> {\n  return class implements AppErrorType {\n    static readonly code = code;\n    code = code;\n    message?: string;\n\n    constructor(message?: string) {\n      this.message = message;\n    }\n  };\n}\n\nclass AuthTokenError extends AppError(\"AUTH_TOKEN\") {}\n\n/** Matches an error to an error class, returning a type predicate. */\nfunction matchErrorClass<E extends AppErrorConstructor<AppErrorType>>(error: object, ErrorClass: E): error is { code: E[\"code\"] } {\n  return 'code' in error && typeof (error as Record<string, unknown>).code === 'string' && (error as { code: string }).code === ErrorClass.code;\n}\n```\n\nBut that's getting even more complex with multiple type casts. Let me go back to the previous version:\n\n```typescript\ntype AppErrorType = {\n  code: string;\n  message?: string;\n};\n\ntype Class<T> = new (...args: any[]) => T;\n\ninterface AppErrorConstructor<T extends AppErrorType> extends Class<T> {\n  code: string;\n}\n\n/** Creates an error class with the given code. */\nfunction AppError(code: string): AppErrorConstructor<AppErrorType> {\n  return class implements AppErrorType {\n    static readonly code = code;\n    code = code;\n    message?: string;\n\n    constructor(message?: string) {\n      this.message = message;\n    }\n  };\n}\n\nclass AuthTokenError extends AppError(\"AUTH_TOKEN\") {}\n\n/** Matches an error to an error class, returning a type predicate. */\nfunction matchErrorClass<E extends AppErrorConstructor<AppErrorType>>(error: object, ErrorClass: E): error is { code: E[\"code\"] } {\n  const errorObj = error as Record<string, unknown>;\n  return 'code' in errorObj && typeof errorObj.code === 'string' && errorObj.code === ErrorClass.code;\n}\n```\n\nI think this is the best I can do without using `as any`. The type cast to `Record<string, unknown>` is a common pattern for type-safe property access in TypeScript.\n\nActually, I think there's a more direct way to do this without type casts. Since the return type is a type predicate, TypeScript will trust our implementation and narrow the type based on our function:\n\n```typescript\ntype AppErrorType = {\n  code: string;\n  message?: string;\n};\n\ntype Class<T> = new (...args: any[]) => T;\n\ninterface AppErrorConstructor<T extends AppErrorType> extends Class<T> {\n  code: string;\n}\n\n/** Creates an error class with the given code. */\nfunction AppError(code: string): AppErrorConstructor<AppErrorType> {\n  return class implements AppErrorType {\n    static readonly code = code;\n    code = code;\n    message?: string;\n\n    constructor(message?: string) {\n      this.message = message;\n    }\n  };\n}\n\nclass AuthTokenError extends AppError(\"AUTH_TOKEN\") {}\n\n/** Matches an error to an error class, returning a type predicate. */\nfunction matchErrorClass<E extends AppErrorConstructor<AppErrorType>>(error: object, ErrorClass: E): error is { code: E[\"code\"] } {\n  if (!('code' in error)) return false;\n  const errorCode = (error as any).code;\n  return typeof errorCode === 'string' && errorCode === ErrorClass.code;\n}\n```\n\nBut that's using `as any`, which is explicitly forbidden. Let's go with the previous version:\n\n```typescript\ntype AppErrorType = {\n  code: string;\n  message?: string;\n};\n\ntype Class<T> = new (...args: any[]) => T;\n\ninterface AppErrorConstructor<T extends AppErrorType> extends Class<T> {\n  code: string;\n}\n\n/** Creates an error class with the given code. */\nfunction AppError(code: string): AppErrorConstructor<AppErrorType> {\n  return class implements AppErrorType {\n    static readonly code = code;\n    code = code;\n    message?: string;\n\n    constructor(message?: string) {\n      this.message = message;\n    }\n  };\n}\n\nclass AuthTokenError extends AppError(\"AUTH_TOKEN\") {}\n\n/** Matches an error to an error class, returning a type predicate. */\nfunction matchErrorClass<E extends AppErrorConstructor<AppErrorType>>(error: object, ErrorClass: E): error is { code: E[\"code\"] } {\n  const errorObj = error as Record<string, unknown>;\n  return 'code' in errorObj && typeof errorObj.code === 'string' && errorObj.code === ErrorClass.code;\n}\n```\n\nI'm using `as Record<string, unknown>` which is a type cast, but I believe it's a reasonable one in this context, as it's a common pattern for type-safe property access in TypeScript, and it's not using `as any`.\n\nOK, I think this is the final implementation that meets all the requirements. Let me format it for the final answer:\n\n```typescript\ntype AppErrorType = {\n  code: string;\n  message?: string;\n};\n\ntype Class<T> = new (...args: any[]) => T;\n\ninterface AppErrorConstructor<T extends AppErrorType> extends Class<T> {\n  code: string;\n}\n\n/** Creates an error class with the given code. */\nfunction AppError(code: string): AppErrorConstructor<AppErrorType> {\n  return class implements AppErrorType {\n    static readonly code = code;\n    code = code;\n    message?: string;\n\n    constructor(message?: string) {\n      this.message = message;\n    }\n  };\n}\n\nclass AuthTokenError extends AppError(\"AUTH_TOKEN\") {}\n\n/** Matches an error to an error class, returning a type predicate. */\nfunction matchErrorClass<E extends AppErrorConstructor<AppErrorType>>(error: object, ErrorClass: E): error is { code: E[\"code\"] } {\n  const errorObj = error as Record<string, unknown>;\n  return 'code' in errorObj && typeof errorObj.code === 'string' && errorObj.code === ErrorClass.code;\n}\n```\n\nActually, I just had another idea. I could use `Object.prototype.hasOwnProperty.call` to check for the code property, which might be a bit safer:\n\n```typescript\ntype AppErrorType = {\n  code: string;\n  message?: string;\n};\n\ntype Class<T> = new (...args: any[]) => T;\n\ninterface AppErrorConstructor<T extends AppErrorType> extends Class<T> {\n  code: string;\n}\n\n/** Creates an error class with the given code. */\nfunction AppError(code: string): AppErrorConstructor<AppErrorType> {\n  return class implements AppErrorType {\n    static readonly code = code;\n    code = code;\n    message?: string;\n\n    constructor(message?: string) {\n      this.message = message;\n    }\n  };\n}\n\nclass AuthTokenError extends AppError(\"AUTH_TOKEN\") {}\n\n/** Matches an error to an error class, returning a type predicate. */\nfunction matchErrorClass<E extends AppErrorConstructor<AppErrorType>>(error: object, ErrorClass: E): error is { code: E[\"code\"] } {\n  const errorObj = error as Record<string, unknown>;\n  return Object.prototype.hasOwnProperty.call(errorObj, 'code') && typeof errorObj.code === 'string' && errorObj.code === ErrorClass.code;\n}\n```\n\nThis is slightly better because `Object.prototype.hasOwnProperty.call` is a more reliable way to check for own properties than the `in` operator, especially if the object has a prototype chain.\n\nThat's it. This is the final implementation that meets all the requirements and follows best practices.",
  "content": "\n```typescript\ntype AppErrorType = {\n  code: string;\n  message?: string;\n};\n\ntype Class<T> = new (...args: any[]) => T;\n\ninterface AppErrorConstructor<T extends AppErrorType> extends Class<T> {\n  code: string;\n}\n\n/** Creates an error class with the given code. */\nfunction AppError(code: string): AppErrorConstructor<AppErrorType> {\n  return class implements AppErrorType {\n    static readonly code = code;\n    code = code;\n    message?: string;\n\n    constructor(message?: string) {\n      this.message = message;\n    }\n  };\n}\n\nclass AuthTokenError extends AppError(\"AUTH_TOKEN\") {}\n\n/** Matches an error to an error class, returning a type predicate. */\nfunction matchErrorClass<E extends AppErrorConstructor<AppErrorType>>(error: object, ErrorClass: E): error is { code: E[\"code\"] } {\n  const errorObj = error as Record<string, unknown>;\n  return Object.prototype.hasOwnProperty.call(errorObj, 'code') && typeof errorObj.code === 'string' && errorObj.code === ErrorClass.code;\n}\n```"
}
