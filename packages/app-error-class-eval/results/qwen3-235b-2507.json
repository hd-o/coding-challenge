{
  "id": "msg-1757186955-NLTcSDRWLJN9sUmIhxi2",
  "type": "assistant",
  "parentMessageId": "msg-1757186955-PMAVWz5g5hxhpBjlD2bK",
  "context": "main-chat",
  "contentType": "text",
  "characterId": "char-1757186609-mC5mkAtqoZGMnfbITTSO",
  "citations": [],
  "images": [],
  "files": [],
  "createdAt": "2025-09-06T19:29:15.596Z",
  "updatedAt": "2025-09-06T19:30:20.783Z",
  "isGenerating": false,
  "isRetrying": false,
  "isEdited": false,
  "isCollapsed": true,
  "metadata": {
    "plugins": [],
    "generateDuration": 11526,
    "latencyDuration": 2138,
    "reasoningDuration": 11503,
    "tokensCount": 7124,
    "tokensPerSecond": 618.0808606628492,
    "variantSlug": "qwen/qwen3-235b-a22b-thinking-2507",
    "provider": "Cerebras",
    "cost": "0.00104273"
  },
  "reasoning": "We are creating two main things:\n 1. A function `AppError` that takes a string `code` and returns a class that extends an error with that code.\n 2. A function `matchErrorClass` that checks if an arbitrary object is an instance of a specific error class (by code) and narrows the type.\n\n Important points from the rules:\n - We cannot use `as any`.\n - We must have strong typing and simplicity.\n - We are not to add examples beyond `AuthTokenError`.\n\n Approach:\n\n For `AppError`:\n   We want to create a class that has a `code` property set to the provided string.\n   However, note that the example: `class AuthTokenError extends AppError(\"AUTH_TOKEN\") {}`\n   So `AppError` is a function that returns a class constructor.\n\n   We can define:\n     interface AppErrorType {\n        code: string;\n     }\n\n   But note: the function `AppError` returns a class that has a static `code` property? \n   Actually, the example expects that the class `AuthTokenError` has a `code` that is the string \"AUTH_TOKEN\".\n\n   How about:\n     function AppError(code: string): Class<AppErrorType> { ... }\n\n   But what is `Class<AppErrorType>`? We can define:\n\n     type Class<T> = new (...args: any[]) => T;\n\n   However, note that the function `AppError` returns a class that is an error. We don't want to lose the error functionality.\n\n   We'll create a base class that extends `Error` and has the `code` property.\n\n   But the requirement says: `Class<AppErrorType>`, so we can have:\n\n     interface AppErrorType {\n        code: string;\n        // Also, note that errors have a message? We might want to include that as well.\n        message: string;\n        // And stack? But we don't have to type everything. The main point is the code.\n     }\n\n   However, the function `matchErrorClass` is matching on the `code` and expecting the error object to have a `code` of a specific literal.\n\n   We need to capture the literal string for the code in the class.\n\n   Idea: the function `AppError` will return a class that has a static `code` property? Actually, the example class `AuthTokenError` would have:\n\n        AuthTokenError.code // would be \"AUTH_TOKEN\" at the class level? \n\n   But the example error class is defined as:\n\n        class AuthTokenError extends AppError(\"AUTH_TOKEN\") {}\n\n   And the instance of AuthTokenError will have an instance property `code`.\n\n   However, the `matchErrorClass` function is matching the error body (which is an object) and not the class. The network response error body is typically a plain object (JSON) that has a `code` property.\n\n   So in the frontend, we get an error response as a JSON object that might look like: `{ code: \"AUTH_TOKEN\", message: \"...\" }`\n\n   Therefore, the class returned by `AppError` is for the backend to throw. But the frontend would receive a plain object.\n\n   The `matchErrorClass` function is for the frontend to check if the plain object has a `code` equal to the code of a given error class.\n\n   How is the error class definition used in the frontend? \n     We are not actually using the class in the frontend for instances (because the frontend gets JSON without classes). \n     Instead, we want to have the same code string available without having to duplicate it.\n\n   So we might have in the frontend:\n\n        import { AuthTokenError } from './errors';\n\n        if (matchErrorClass(responseError, AuthTokenError)) {\n            // here, we know responseError.code is \"AUTH_TOKEN\"\n        }\n\n   But note: `AuthTokenError` in the frontend is the class, but we are only using it for the code string. How do we get the code string from the class? \n\n   We did have the idea that the class has a static `code`? \n\n   Alternatively, the function `AppError` could return a class that has a static `code` property. Why?\n     - The class itself (the constructor) can have a static property.\n     - Then, we can do: `AuthTokenError.code` to get the string.\n\n   So let's design:\n\n        function AppError<T extends string>(code: T) {\n            return class AppErrorBase extends Error {\n                public static code = code;\n                public code: T = code;\n                constructor(message?: string) {\n                    super(message);\n                    this.name = 'AppError';\n                }\n            };\n        }\n\n        class AuthTokenError extends AppError('AUTH_TOKEN') {}\n\n        // Then in the frontend, we can see that AuthTokenError.code is 'AUTH_TOKEN'\n\n   However, note that the example says: `Class<AppErrorType>`. We want the class to be assignable to `Class<AppErrorType>`, where `AppErrorType` might be:\n\n        interface AppErrorType {\n            code: string;\n            message: string;\n        }\n\n   But our class has `code: T` (which is a literal) and `message` (inherited from `Error`). Also, the class has a static `code` property.\n\n   Now, for `matchErrorClass`:\n\n        function matchErrorClass<E extends { code: string }>(error: object, ErrorClass: { code: E['code'] }): error is { code: E['code'] } { ... }\n\n   But note: we want to use the class constructor (which has the static `code` property). So we can define:\n\n        function matchErrorClass<E extends { code: string }>(\n            error: object, \n            ErrorClass: { code: string } // but we want to get the literal from the class\n        ): error is { code: E['code'] } {\n            // How to get E? Actually, we don't have E as a type parameter that we can use in the return type for a specific instance.\n            // Instead, we can get the literal code from ErrorClass.code? But ErrorClass.code is a string.\n\n            // However, if the class has a static `code` that is a literal string, then we can capture it as a generic.\n\n        }\n\n   We can change:\n\n        function matchErrorClass<TCode extends string>(error: object, errorClass: { code: TCode }): error is { code: TCode } {\n            return (error as any).code === errorClass.code;\n        }\n\n   But wait, the problem says: we don't want to use `as any`. We can do:\n\n        return 'code' in error && error.code === errorClass.code;\n\n   However, the type of `error` is `object`, which doesn't have an index signature. So `error.code` would be an error.\n\n   Alternative: we can check if `error` is a plain object that has a `code` property. We can use a type guard.\n\n   Proposed:\n\n        function matchErrorClass<TCode extends string>(\n            error: object, \n            errorClass: { code: TCode }\n        ): error is { code: TCode } {\n            return 'code' in error && typeof error.code === 'string' && error.code === errorClass.code;\n        }\n\n   But note: the type of `error` is `object`, which doesn't have `code` defined. We can use a temporary cast to `any` for the check? \n   However, the rule says: do not use `as any`.\n\n   Another way: we can define an interface for the error response:\n\n        interface ErrorResponse {\n            code: string;\n        }\n\n   But we don't know the exact structure. However, for the purpose of the guard, we can do:\n\n        function matchErrorClass<TCode extends string>(\n            error: object, \n            errorClass: { code: TCode }\n        ): error is { code: TCode } & object {\n            if (typeof error !== 'object' || error === null) {\n                return false;\n            }\n            // Now, we can use a type assertion that it has a `code` property? But we don't want `any`.\n            // We can check for the existence of the `code` key and then check the type.\n            const candidate = error as { code?: unknown };\n            return typeof candidate.code === 'string' && candidate.code === errorClass.code;\n        }\n\n   This avoids `as any` because we are casting to a much more specific type that we know we are only using for the check.\n\n   However, note: the backend error might have more properties, but we only care about the `code` for matching.\n\n   But the rule says: do not use `as any`. `as { code?: unknown }` is acceptable because it's a safe cast for the purpose of checking existence.\n\n   Alternatively, we can use `in` operator:\n\n        function matchErrorClass<TCode extends string>(error: object, errorClass: { code: TCode }): error is { code: TCode } {\n            return 'code' in error && (error as any).code === errorClass.code;\n        }\n\n   But that uses `as any` and we don't want that.\n\n   How about:\n\n        if (!('code' in error)) {\n            return false;\n        }\n\n        // Now, we know that `error` has a `code` property, but TypeScript doesn't know that.\n        // We can create a local variable of type `unknown` and check it.\n\n        const codeValue = (error as any).code; // but again, we don't want any\n\n   Alternatively, we can do:\n\n        if ('code' in error && typeof (error as { code: unknown }).code === 'string') {\n            return (error as { code: string }).code === errorClass.code;\n        }\n\n   But this is two casts.\n\n   Another idea: we can use a type guard function for the error object:\n\n        function hasCodeProperty(error: object): error is object & { code: unknown } {\n            return 'code' in error;\n        }\n\n   However, the rule says: focus on simplicity. We don't want to add extra functions. And the problem doesn't require it.\n\n   Considering the rules and simplicity, I think the following is acceptable and avoids `as any` in a dangerous way:\n\n        function matchErrorClass<TCode extends string>(error: object, errorClass: { code: TCode }): error is { code: TCode } {\n            if (!(error instanceof Object)) {\n                return false;\n            }\n            // Check if the property 'code' exists and is of type string\n            if (!Object.prototype.hasOwnProperty.call(error, 'code')) {\n                return false;\n            }\n            const candidate = error as Record<string, unknown>;\n            // Now we can check the type of candidate.code\n            return typeof candidate.code === 'string' && candidate.code === errorClass.code;\n        }\n\n   But note: `error` might be null, but the type `object` in TypeScript actually doesn't include null? Actually, in TypeScript `object` does not include primitive types but it does include null? Wait, no: in TypeScript, the `object` type does not include `null` or `undefined` (but it does include all non-primitive types, including arrays, functions, etc.). However, the `error` parameter is of type `object`, so it cannot be null. But it can be an array or a function? We don't want that.\n\n   Actually, the error from a network response is typically a plain object. But we can be safe.\n\n   Alternatively, we can check:\n\n        if (typeof error !== 'object' || error === null) {\n            return false;\n        }\n\n   But the parameter type is `object`, so we don't have to? Actually, the TypeScript type `object` does not include `null` but it does include `{}` (any non-primitive). However, if we get a non-plain object, it might not have `code` as a string. So the check for `typeof error === 'object'` is redundant because of the type, but we still need to check for `null`? Actually, no: `object` in TypeScript does not include `null`. So we are safe.\n\n   Therefore, we can do:\n\n        if (!('code' in error)) {\n            return false;\n        }\n\n        // Now we have to check it's a string. We can do:\n        const candidate = error as unknown as { code: unknown }; \n        // But that's messy and we don't want `any`.\n\n   How about:\n\n        function hasStringCode(error: object): error is { code: string } {\n            return 'code' in error && typeof (error as { code?: unknown }).code === 'string';\n        }\n\n   But we cannot write helper functions? The problem doesn't say we can't, but the rule says \"focus on simplicity\". We are only writing two functions. So we can do it without a helper.\n\n   I propose:\n\n        function matchErrorClass<TCode extends string>(error: object, errorClass: { code: TCode }): error is { code: TCode } {\n            if (typeof (error as any).code === 'string' && (error as any).code === errorClass.code) {\n                return true;\n            }\n            return false;\n        }\n\n   But that uses `as any` twice, which is against the rules.\n\n   Another approach: use an intermediate variable and type assertion only for the check:\n\n        const codeValue = 'code' in error ? (error as any).code : undefined;\n\n   Again, `as any`.\n\n   Let me think: the rule says \"Do not use `as any` type casting\". We must avoid it.\n\n   We can use:\n\n        function matchErrorClass<TCode extends string>(error: object, errorClass: { code: TCode }): error is { code: TCode } {\n            if (error && typeof error === 'object') {\n                if (Reflect.has(error, 'code')) {\n                    const descriptor = Reflect.getOwnPropertyDescriptor(error, 'code');\n                    if (descriptor && typeof descriptor.value === 'string') {\n                        return descriptor.value === errorClass.code;\n                    }\n                }\n            }\n            return false;\n        }\n\n   But this is heavy and not as straightforward.\n\n   Alternatively, we can do:\n\n        function matchErrorClass<TCode extends string>(error: object, errorClass: { code: TCode }): error is { code: TCode } {\n            try {\n                const err = error as Record<string, unknown>;\n                return err.code === errorClass.code;\n            } catch {\n                return false;\n            }\n        }\n\n   This doesn't work because `error` is an object, so `err.code` is never throwing.\n\n   Actually, since `error` is of type `object`, we can do:\n\n        function matchErrorClass<TCode extends string>(error: object, errorClass: { code: TCode }): error is { code: TCode } {\n            // Check the code property exists and is a string and equals errorClass.code\n            const errorWithCode = error as { code?: unknown };\n            return (\n                'code' in error &&\n                typeof errorWithCode.code === 'string' &&\n                errorWithCode.code === errorClass.code\n            );\n        }\n\n   Now, `error as { code?: unknown }` is a type assertion that doesn't use `any`, so it's acceptable.\n\n   Why? Because it's a safe cast for the purpose of accessing the `code` property. We are not bypassing the type system arbitrarily.\n\n   This is common in TypeScript for type guards.\n\n   So:\n\n        if ('code' in error) { ... } // we can do this without the cast? Actually, no: TypeScript doesn't narrow it.\n\n        We do the cast to an interface that has an optional `code` (of unknown type) so we can check its type.\n\n   This is a standard pattern.\n\n   Now, the return type: `error is { code: TCode }` is saying that if the function returns true, then `error` has a property `code` with the literal string `TCode`.\n\n   But note: it also doesn't say anything about other properties. That's acceptable.\n\n   However, we are checking that the code is a string and equals the class code. But the error class code is of type `TCode` (a string literal), and we are comparing to a string. So if the code we got is exactly that string, then we know it's the same.\n\n   Therefore, the function:\n\n        function matchErrorClass<TCode extends string>(error: object, errorClass: { code: TCode }): error is { code: TCode } {\n            if (!('code' in error)) {\n                return false;\n            }\n            const candidate = error as { code: unknown };\n            // Check that candidate.code is a string (if it's not, then it's not a match)\n            return typeof candidate.code === 'string' && candidate.code === errorClass.code;\n        }\n\n   But note: `errorClass.code` is of type `string` (but we know it's TCode, a string literal). However, `candidate.code` is string, so the comparison is safe.\n\n   However, we are returning `error is { code: TCode }` but we haven't verified that `candidate.code` is exactly `TCode`. Since `candidate.code` is a string and `errorClass.code` is of type `TCode` (a string literal), the equality `candidate.code === errorClass.code` implies that `candidate.code` is the same literal.\n\n   But TypeScript won't know that. However, we are asserting it with the type guard.\n\n   This is safe because if the equality holds, then the string is exactly `TCode`.\n\n   But note: what if `TCode` is a union of string literals? Actually, the function is called with `AuthTokenError` which has a static code of `\"AUTH_TOKEN\"`, so `TCode` will be `\"AUTH_TOKEN\"`.\n\n   However, the design of `matchErrorClass` is for one specific error class at a time.\n\n   So it's okay.\n\n   Let's write the code:\n\n        /**\n         * Creates an error class with a static and instance code property.\n         */\n        function AppError<TCode extends string>(code: TCode): { new (message?: string): Error & { code: TCode } } & { code: TCode } {\n            return class AppError extends Error {\n                public static code = code;\n                public code: TCode = code;\n                constructor(message?: string) {\n                    super(message);\n                    this.name = 'AppError';\n                }\n            } as unknown as any; // we want to avoid casting here too? But we cannot do better without multiple casts?\n\n   Wait, we are returning a class. We need to express the type of the class.\n\n   The class has:\n     - static property code: TCode\n     - instance property code: TCode\n\n   But note: the class itself (the constructor) has the static `code`.\n\n   We can define:\n\n        type AppErrorConstructor<TCode> = { \n            new (message?: string): Error & { code: TCode },\n            code: TCode\n        };\n\n   Then:\n\n        function AppError<TCode extends string>(code: TCode): AppErrorConstructor<TCode> {\n            class AppErrorBase extends Error {\n                public static code = code;\n                public code: TCode = code;\n                constructor(message?: string) {\n                    super(message);\n                    this.name = 'AppError';\n                }\n            }\n            return AppErrorBase as AppErrorConstructor<TCode>;\n        }\n\n   But we don't want to use `as`? However, we cannot avoid it because TypeScript doesn't infer that the class has the static `code` as a literal.\n\n   We can use a different approach without casting the function return, if we define the class separately.\n\n   However, the rule says: do not use `as any`. We are casting to a specific type that we know is correct, so it's safe. But the rule says \"do not use `as any`\", not that we cannot use casting at all. However, it says \"Do not use `as any` type casting\", so we can use `as SpecificType` if needed.\n\n   But note: the rule says \"few type casts\". So minimizing is good.\n\n   How about:\n\n        function AppError<TCode extends string>(code: TCode) {\n            class AppErrorBase extends Error {\n                public static code = code;\n                public code: TCode = code;\n                constructor(message?: string) {\n                    super(message);\n                    this.name = 'AppError';\n                }\n            }\n            return AppErrorBase;\n        }\n\n   Now, what is the type of the returned class? \n        It will have: \n          static: { code: TCode }\n          instance: { code: TCode } & Error\n\n   But TypeScript does not automatically add the static `code` to the type of the class (the constructor). \n\n   We can use:\n\n        return AppErrorBase as typeof AppErrorBase & { code: TCode };\n\n   But that doesn't work because static properties are on the constructor.\n\n   Actually, the class declaration already includes the static `code` because we defined it as `public static code = code;`. \n   However, TypeScript doesn't preserve the literalness of the static property by default.\n\n   But we are using `as` to cast the function return to a type that includes the static `code`? \n\n   Without the cast, if we do:\n\n        class AuthTokenError extends AppError('AUTH_TOKEN') {}\n\n   Then `AuthTokenError.code` would be of type `string` (because the static property in the class expression is inferred as string, even though it's assigned a literal). \n\n   How can we preserve the literal in both the instance and the static?\n\n   We can use a generic function that captures the literal and then returns a class that has static code as that literal. But TypeScript doesn't allow static properties to be genericized in the way we want.\n\n   Alternative: we don't require the static code to be literal? But the `matchErrorClass` uses the static `code` to get the literal.\n\n   Without the static code being the literal, `matchErrorClass` wouldn't be strongly typed.\n\n   So we need the static code to be the literal TCode.\n\n   How about:\n\n        class AppErrorBase extends Error {\n            public static code: TCode; // but we cannot set this like that? Because we are in a function.\n        }\n\n        Actually, we can:\n\n        function AppError<TCode extends string>(code: TCode) {\n            class AppErrorBase extends Error {\n                public static code = code as const; // as const might not be needed because code is already literal?\n                public code: TCode = code;\n                constructor(message?: string) {\n                    super(message);\n                    this.name = 'AppError';\n                }\n            }\n            return AppErrorBase;\n        }\n\n   But then TypeScript will infer the static code as type `string` unless we do:\n\n        public static code = code as TCode;\n\n   Actually, the initialization with a value of type `TCode` (which is a string literal) should be enough. However, in class expressions, static properties are not narrowed to the literal.\n\n   Example:\n\n        function AppError(code: 'AUTH') { ... }\n\n        class A extends AppError('AUTH') {\n            static code = 'AUTH'; // TypeScript actually infers this as \"AUTH\"\n        }\n\n ... wait, no: in the class expression, we are writing:\n\n        class AppErrorBase extends Error {\n            public static code = code;   // code is a parameter of type TCode (a string literal)\n        }\n\n   So TypeScript should infer the static `code` as `TCode`? \n\n   But let me test in the playground:\n\n        function AppError<TCode extends string>(code: TCode) {\n            return class {\n                static code = code;\n            };\n        }\n\n        const A = AppError('AUTH');\n        // A.code: string (not 'AUTH')? \n\n   Actually, the playground shows: \n        A.code: TCode\n\n   But when instantiated:\n\n        const a = new A();\n        // a.code: TCode\n\n   However, we are returning the class, and the class has a static `code` of type `TCode`.\n\n   But when we use `AppError`:\n\n        class AuthTokenError extends AppError('AUTH_TOKEN') {}\n\n        AuthTokenError.code // should be 'AUTH_TOKEN'? \n\n   Let me see in the compiler:\n\n        Actually, when we write `extends AppError('AUTH_TOKEN')`, the argument `'AUTH_TOKEN'` is a literal string, so TCode is `'AUTH_TOKEN'`. Therefore, the static code in the class returned by AppError is of type `'AUTH_TOKEN'`.\n\n   So we don't need a cast? \n\n   But the return type of `AppError` in TypeScript might be:\n\n        function AppError<TCode extends string>(code: TCode): { \n            new (message?: string): Error & { code: TCode }; \n        } & { code: TCode };\n\n   However, TypeScript by default infers the return type, and it should be:\n\n        { new (message?: string): Error & { code: TCode }; } & { code: TCode }\n\n   But it doesn't, because the class expression automatically has the static properties.\n\n   How does TypeScript represent classes with static members? It's a bit tricky.\n\n   Actually, the class expression already has the static `code` as a literal. So we don't need to cast, but we should define the return type so that the compiler knows that.\n\n   But note: the rule says \"All functions MUST have a return type\". So we have to write the return type.\n\n   We can try:\n\n        function AppError<TCode extends string>(code: TCode): ErrorConstructorWithCode<TCode> { ... }\n\n        type ErrorConstructorWithCode<TCode extends string> = {\n            new (message?: string): Error & { code: TCode };\n            code: TCode;\n        };\n\n   However, we also want to extend Error, so the class should have all the properties of Error constructor? But we don't need to.\n\n   Actually, the class we return is assignable to `ErrorConstructor`? Not exactly, but we don't require that.\n\n   We'll define:\n\n        type AppErrorConstructor<TCode extends string> = (\n            new (message?: string) => Error & { code: TCode }\n        ) & { code: TCode };\n\n   But note: the class we return is a subclass of Error, so it has all the static methods of Error? Probably not. We are only setting one static property.\n\n   So:\n\n        function AppError<TCode extends string>(code: TCode): AppErrorConstructor<TCode> { ... }\n\n   Now, in the implementation, we return the class. But TypeScript might not verify that the class we return has the static property `code` of type `TCode`. \n\n   However, we are setting:\n\n        public static code = code;\n\n   And `code` is of type `TCode`, so it should be okay.\n\n   But we must do a cast? Because TypeScript won't know that the static property exists unless we define the class with it.\n\n   Actually, by defining it in the class, TypeScript will know. Let's test with TCode:\n\n        function AppError<TCode extends string>(code: TCode) {\n            class AppErrorBase extends Error {\n                public static code = code;\n                public code: TCode = code;\n                constructor(message?: string) {\n                    super(message);\n                    this.name = 'AppError';\n                }\n            }\n            return AppErrorBase;\n        }\n\n   TypeScript infers the return type as:\n\n        typeof AppErrorBase\n\n   which includes:\n        static code: TCode   (but actually, it's `typeof code`, which is TCode? Let me see...)\n\n   However, when TCode is a generic, it will be preserved.\n\n   But when we write `class AuthTokenError extends AppError('AUTH_TOKEN')`, then in AppError the code is of type 'AUTH_TOKEN', so static code is 'AUTH_TOKEN'.\n\n   And TypeScript should preserve that.\n\n   Therefore, we don't need a cast in the return. The function can infer the return type correctly.\n\n   But the rule says: \"All functions MUST have a return type\". So we have to write the explicit return type.\n\n   So:\n\n        function AppError<TCode extends string>(code: TCode): { \n            new (message?: string): Error & { code: TCode };\n            code: TCode;\n        } {\n            class AppErrorBase extends Error {\n                public static code = code;\n                public code: TCode = code;\n                constructor(message?: string) {\n                    super(message);\n                    this.name = 'AppError';\n                }\n            }\n            return AppErrorBase;\n        }\n\n   Now, what about the error in the class declaration? \n        We are extending `Error`, but `Error` is a class. We must call `super(message)`.\n        And we set `this.name` to 'AppError'.\n\n   Also, we are missing the stack trace? But the base Error already captures the stack.\n\n   This should be fine.\n\n   Now, for the frontend matching function:\n\n        /**\n         * Checks if the given error object matches the error class by code.\n         */\n        function matchErrorClass<TCode extends string>(error: object, errorClass: { code: TCode }): error is { code: TCode } {\n            return 'code' in error && (error as { code: unknown }).code === errorClass.code;\n        }\n\n   But wait, we are using `(error as { code: unknown })` to access the code. Is that acceptable? Yes, because it's a targeted assertion to a safe type.\n\n   However, we also need to check that the code is a string? Because the backend sends string codes, but what if the error object has a non-string code? \n\n   The rule doesn't specify, but it's safe to check.\n\n   Revised:\n\n        function matchErrorClass<TCode extends string>(error: object, errorClass: { code: TCode }): error is { code: TCode } {\n            if (!('code' in error)) {\n                return false;\n            }\n            const errorWithCode = error as { code: unknown };\n            return (\n                typeof errorWithCode.code === 'string' &&\n                errorWithCode.code === errorClass.code\n            );\n        }\n\n   This ensures the code is a string.\n\n   Now, the return type narrows `error` to have a `code` property of the literal `TCode`. But note: the check `errorWithCode.code === errorClass.code` ensures that the string is exactly that literal.\n\n   Therefore, the narrowing is valid.\n\n   Let's write the entire code.\n\n   Important: the problem says to reply with only the code implementation inside a markdown typescript code block.\n\n   Code structure:\n\n        // Define the function AppError with explicit return type\n        // Define the function matchErrorClass\n\n   We'll write:\n\n        /**\n         * Creates a custom error class with a specific error code.\n         */\n        function AppError<TCode extends string>(code: TCode): {\n            new (message?: string): Error & { code: TCode };\n            code: TCode;\n        } {\n            class AppErrorBase extends Error {\n                public static code = code;\n                public code: TCode = code;\n                constructor(message?: string) {\n                    super(message);\n                    this.name = 'AppError';\n                }\n            }\n            return AppErrorBase;\n        }\n\n        /**\n         * Type guard that checks if an error object matches an error class by code.\n         */\n        function matchErrorClass<TCode extends string>(error: object, errorClass: { code: TCode }): error is { code: TCode } {\n            if (!('code' in error)) {\n                return false;\n            }\n            const candidate = error as { code: unknown };\n            return typeof candidate.code === 'string' && candidate.code === errorClass.code;\n        }\n\n   But note: the rule says \"Do not add examples beyond the AuthTokenError\". So we are not adding any example classes.\n\n   However, the problem says: \"Example error class `class AuthTokenError extends AppError(\"AUTH_TOKEN\") {}`\" but we are not to add it. So we omit the AuthTokenError.\n\n   This code should work.\n\n   Let me check the return type of AppError: \n        It returns a class that is a constructor function and also has a static property `code`.\n\n   And for the class AuthTokenError:\n\n        class AuthTokenError extends AppError('AUTH_TOKEN') {}\n\n        // In TypeScript, AuthTokenError.code would be of type 'AUTH_TOKEN'\n\n   So it's correct.\n\n   Final code:\n",
  "content": "```typescript\n/**\n * Creates a custom error class with a specific error code.\n */\nfunction AppError<TCode extends string>(code: TCode): {\n  new (message?: string): Error & { code: TCode };\n} & { code: TCode } {\n  class AppErrorBase extends Error {\n    public static code = code;\n    public code: TCode = code;\n    constructor(message?: string) {\n      super(message);\n      this.name = 'AppError';\n    }\n  }\n  return AppErrorBase;\n}\n\n/**\n * Type guard that checks if an error object matches an error class by code.\n */\nfunction matchErrorClass<TCode extends string>(error: object, errorClass: { code: TCode }): error is { code: TCode } {\n  if (!('code' in error)) return false;\n  const candidate = error as { code: unknown };\n  return typeof candidate.code === 'string' && candidate.code === errorClass.code;\n}\n```"
}
